name: 'Kustomize Deploy'
description: 'Complete kustomize deployment with GitOps detection and metadata extraction'
author: 'KoalaOps'

branding:
  icon: 'package'
  color: 'purple'

inputs:
  working_directory:
    description: 'Working directory for operations'
    required: false
    default: '.'
  overlay_dir:
    description: 'Path to kustomize overlay directory (relative to working_directory)'
    required: true
  service_name:
    description: 'Service name'
    required: true
  image:
    description: 'Full image with tag (e.g., myregistry/myapp:v1.2.3)'
    required: true
  environment:
    description: 'Environment name'
    required: true
  actor:
    description: 'User deploying (defaults to github.actor)'
    required: false
    default: ${{ github.actor }}
  run_id:
    description: 'Run ID for tracking (defaults to github.run_id)'
    required: false
    default: ${{ github.run_id }}
  detect_gitops:
    description: 'Auto-detect GitOps mode from manifests'
    required: false
    default: 'true'
  force_mode:
    description: 'Force deployment mode (gitops, kubectl, or auto)'
    required: false
    default: 'auto'
  commit_message:
    description: 'Commit message for GitOps (has defaults)'
    required: false
  create_namespace:
    description: 'Create namespace if it does not exist'
    required: false
    default: 'true'
  wait_timeout:
    description: 'Timeout for waiting on deployments (seconds)'
    required: false
    default: '120'

outputs:
  mode:
    description: 'Deployment mode used (gitops or kubectl)'
    value: ${{ steps.detect.outputs.mode }}
  namespace:
    description: 'Kubernetes namespace'
    value: ${{ steps.extract.outputs.namespace }}
  fullname:
    description: 'Full deployment name (with any prefixes)'
    value: ${{ steps.extract.outputs.fullname }}
  deployment:
    description: 'Primary deployment name'
    value: ${{ steps.extract.outputs.deployment }}
  managed_by:
    description: 'Value of managed-by label if found'
    value: ${{ steps.detect.outputs.managed_by }}

runs:
  using: 'composite'
  steps:
    - name: Validate inputs
      shell: bash
      run: |
        if [ ! -d "${{ inputs.working_directory }}/${{ inputs.overlay_dir }}" ]; then
          echo "::error::Overlay directory not found: ${{ inputs.working_directory }}/${{ inputs.overlay_dir }}"
          exit 1
        fi
        
        if [ ! -f "${{ inputs.working_directory }}/${{ inputs.overlay_dir }}/kustomization.yaml" ]; then
          echo "::error::No kustomization.yaml found in overlay directory"
          exit 1
        fi
    
    - name: Update kustomize manifests
      shell: bash
      working-directory: ${{ inputs.working_directory }}/${{ inputs.overlay_dir }}
      run: |
        echo "=� Updating kustomize manifests..."
        
        # Set image
        kustomize edit set image "${{ inputs.image }}"
        
        # Update version label
        TAG="${{ inputs.image }}"
        TAG="${TAG##*:}"  # Extract tag after last colon
        sed -i.bak "s/app.kubernetes.io\/version:.*/app.kubernetes.io\/version: $TAG/g" kustomization.yaml && rm kustomization.yaml.bak || true
        
        # Set annotations
        kustomize edit set annotation "last-deployed-by:${{ inputs.actor }}"
        kustomize edit set annotation "deployment-timestamp:$(date -u +%Y-%m-%dT%H:%M:%SZ)"
        kustomize edit set annotation "deployment-id:${{ inputs.run_id }}"
        kustomize edit set annotation "build.run.url: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
        
        echo " Manifests updated"
    
    - name: Extract metadata
      id: extract
      shell: bash
      working-directory: ${{ inputs.working_directory }}/${{ inputs.overlay_dir }}
      run: |
        echo "=
 Extracting metadata from manifests..."
        
        # Build manifests
        BUILD_RESULT=$(kustomize build)
        
        # Extract namespace
        NAMESPACE=$(echo "$BUILD_RESULT" | grep -m1 "^\s*namespace:" | sed 's/.*namespace:\s*//' | tr -d '[:space:]')
        if [ -z "$NAMESPACE" ]; then
          NAMESPACE="${{ inputs.environment }}"
        fi
        echo "namespace=$NAMESPACE" >> $GITHUB_OUTPUT
        echo "Namespace: $NAMESPACE"
        
        # Extract name prefix if exists
        NAME_PREFIX=$(grep "^namePrefix:" kustomization.yaml 2>/dev/null | sed 's/.*namePrefix:\s*//' | tr -d '[:space:]' || echo "")
        
        # Determine full name
        if [ -n "$NAME_PREFIX" ]; then
          FULLNAME="${NAME_PREFIX}${{ inputs.service_name }}"
        else
          FULLNAME="${{ inputs.service_name }}"
        fi
        echo "fullname=$FULLNAME" >> $GITHUB_OUTPUT
        echo "Full name: $FULLNAME"
        
        # Extract primary deployment
        DEPLOYMENT=$(echo "$BUILD_RESULT" | grep -B1 "kind: Deployment" | grep "name:" | head -1 | sed 's/.*name:\s*//' | tr -d '[:space:]' || echo "$FULLNAME")
        echo "deployment=$DEPLOYMENT" >> $GITHUB_OUTPUT
        echo "Deployment: $DEPLOYMENT"
    
    - name: Detect GitOps mode
      id: detect
      if: inputs.force_mode == 'auto' && inputs.detect_gitops == 'true'
      shell: bash
      working-directory: ${{ inputs.working_directory }}/${{ inputs.overlay_dir }}
      run: |
        echo "=
 Detecting deployment mode..."
        
        BUILD_RESULT=$(kustomize build)
        MANAGED_BY=$(echo "$BUILD_RESULT" | grep "app.kubernetes.io/managed-by:" | head -n1 | sed 's/.*app.kubernetes.io\/managed-by:\s*//' | tr -d '[:space:]')
        
        echo "managed_by=$MANAGED_BY" >> $GITHUB_OUTPUT
        
        if [ "$MANAGED_BY" = "argocd" ]; then
          echo "mode=gitops" >> $GITHUB_OUTPUT
          echo " GitOps mode detected (ArgoCD)"
        elif [ "$MANAGED_BY" = "flux" ]; then
          echo "mode=gitops" >> $GITHUB_OUTPUT
          echo " GitOps mode detected (Flux)"
        else
          echo "mode=kubectl" >> $GITHUB_OUTPUT
          echo "=� Direct deployment mode (kubectl)"
        fi
    
    - name: Set deployment mode
      id: mode
      shell: bash
      run: |
        if [ "${{ inputs.force_mode }}" != "auto" ]; then
          echo "mode=${{ inputs.force_mode }}" >> $GITHUB_OUTPUT
          echo "<� Using forced mode: ${{ inputs.force_mode }}"
        else
          echo "mode=${{ steps.detect.outputs.mode }}" >> $GITHUB_OUTPUT
        fi
    
    # GitOps path: commit changes
    - name: Commit changes for GitOps
      if: steps.mode.outputs.mode == 'gitops'
      uses: stefanzweifel/git-auto-commit-action@v5
      with:
        repository: ${{ inputs.working_directory }}
        commit_message: |
          ${{ inputs.commit_message || format('Deploy {0} {1} to {2} [skip ci]', inputs.service_name, inputs.image, inputs.environment) }}
        file_pattern: '${{ inputs.overlay_dir }}/*'
        commit_user_name: GitHub Actions Bot
        commit_user_email: actions@github.com
    
    # Kubectl path: direct apply
    - name: Create namespace
      if: steps.mode.outputs.mode == 'kubectl' && inputs.create_namespace == 'true'
      shell: bash
      run: |
        NAMESPACE="${{ steps.extract.outputs.namespace }}"
        echo "=� Ensuring namespace exists: $NAMESPACE"
        kubectl create namespace "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -
    
    - name: Apply with kubectl
      if: steps.mode.outputs.mode == 'kubectl'
      shell: bash
      working-directory: ${{ inputs.working_directory }}
      run: |
        NAMESPACE="${{ steps.extract.outputs.namespace }}"
        FULLNAME="${{ steps.extract.outputs.fullname }}"
        
        echo "=� Deploying ${{ inputs.service_name }} to ${{ inputs.environment }}..."
        
        # Apply manifests
        kustomize build "${{ inputs.overlay_dir }}" | kubectl apply -n "$NAMESPACE" -f -
        
        # Wait for rollout
        echo "� Waiting for deployment..."
        if kubectl rollout status deployment/"$FULLNAME" -n "$NAMESPACE" --timeout="${{ inputs.wait_timeout }}s"; then
          echo " Deployment successful"
        else
          echo "::warning::Deployment may not be fully ready"
          kubectl describe deployment "$FULLNAME" -n "$NAMESPACE" | tail -20
        fi
        
        # Show status
        echo "=� Deployment status:"
        kubectl get deployment "$FULLNAME" -n "$NAMESPACE" -o wide || true
        kubectl get pods -l "app=${{ inputs.service_name }}" -n "$NAMESPACE" || true